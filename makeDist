#!/bin/perl
#
# makeDist: Build a BackupPC distribution
#
# DESCRIPTION
#
#   This script should be run with no arguments to build a
#   distribution.  The $Version and $ReleaseDate should be
#   edited below to specify the version name and the release
#   date.  The distribution is createede in the sub-directory
#   dist.  The dsitribution is in the file name:
#
#           dist/BackupPC-$Version.tar.gz.
#
# AUTHOR
#   Craig Barratt <cbarratt@users.sourceforge.net>
#
# COPYRIGHT
#   Copyright (C) 2001-2004  Craig Barratt
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#========================================================================
#

use strict;
use File::Path;
use File::Copy;
use Getopt::Std;

umask(0022);

my $Version     = "2.1.3";
my $ReleaseDate = "21 Jan 2007";
my $DistDir     = "dist/BackupPC-$Version";

my @PerlSrc = qw(
    bin/BackupPC
    bin/BackupPC_archive
    bin/BackupPC_archiveHost
    bin/BackupPC_dump
    bin/BackupPC_link
    bin/BackupPC_nightly
    bin/BackupPC_restore
    bin/BackupPC_sendEmail
    bin/BackupPC_serverMesg
    bin/BackupPC_trashClean
    bin/BackupPC_tarExtract
    bin/BackupPC_tarCreate
    bin/BackupPC_compressPool
    bin/BackupPC_zipCreate
    bin/BackupPC_zcat
    lib/BackupPC/Attrib.pm
    lib/BackupPC/FileZIO.pm
    lib/BackupPC/Lib.pm
    lib/BackupPC/PoolWrite.pm
    lib/BackupPC/View.pm
    lib/BackupPC/CGI/AdminOptions.pm
    lib/BackupPC/CGI/Archive.pm
    lib/BackupPC/CGI/ArchiveInfo.pm
    lib/BackupPC/CGI/Browse.pm
    lib/BackupPC/CGI/DirHistory.pm
    lib/BackupPC/CGI/EmailSummary.pm
    lib/BackupPC/CGI/GeneralInfo.pm
    lib/BackupPC/CGI/HostInfo.pm
    lib/BackupPC/CGI/Lib.pm
    lib/BackupPC/CGI/LOGlist.pm
    lib/BackupPC/CGI/Queue.pm
    lib/BackupPC/CGI/ReloadServer.pm
    lib/BackupPC/CGI/RestoreFile.pm
    lib/BackupPC/CGI/RestoreInfo.pm
    lib/BackupPC/CGI/Restore.pm
    lib/BackupPC/CGI/StartServer.pm
    lib/BackupPC/CGI/StartStopBackup.pm
    lib/BackupPC/CGI/StopServer.pm
    lib/BackupPC/CGI/Summary.pm
    lib/BackupPC/CGI/View.pm
    lib/BackupPC/Lang/de.pm
    lib/BackupPC/Lang/en.pm
    lib/BackupPC/Lang/es.pm
    lib/BackupPC/Lang/fr.pm
    lib/BackupPC/Lang/it.pm
    lib/BackupPC/Lang/nl.pm
    lib/BackupPC/Lang/pt_br.pm
    lib/BackupPC/Xfer/Archive.pm
    lib/BackupPC/Xfer/Smb.pm
    lib/BackupPC/Xfer/Tar.pm
    lib/BackupPC/Xfer/Rsync.pm
    lib/BackupPC/Xfer/RsyncDigest.pm
    lib/BackupPC/Xfer/RsyncFileIO.pm
    lib/BackupPC/Zip/FileMember.pm
    cgi-bin/BackupPC_Admin
);

my %opts;
if ( !getopts("l", \%opts) || @ARGV != 0 ) {
    print("usage: $0 [-l]\n");
    exit(1);
}

#
# Check config parameters
#
my $ConfVars = {};
my $errCnt;

$errCnt += CheckConfigParams("conf/config.pl", $ConfVars, 0);

$errCnt += CheckConfigParams("doc-src/BackupPC.pod", $ConfVars, 1);

#
# These config parameters are not used in the code, so ignore them.
#
$ConfVars->{BackupPCUser} = 2;
$ConfVars->{CgiDir}       = 2;
$ConfVars->{InstallDir}   = 2;
$ConfVars->{CgiImageDir}  = 2;

#
# These config parameters are used in the code to be backward compatible,
# but are not present in the current config file, so ignore them.
#
$ConfVars->{BlackoutHourBegin} = 2;
$ConfVars->{BlackoutHourEnd}   = 2;
$ConfVars->{BlackoutWeekDays}  = 2;
$ConfVars->{RsyncLogLevel}     = 2;

foreach my $file ( @PerlSrc ) {
    $errCnt += CheckConfigParams($file, $ConfVars, 1);
}
if ( !$opts{l} ) {
    $errCnt += CheckLangUsage();
    $errCnt += CheckLangTags();
}
if ( $errCnt ) {
    print("Exiting because of errors\n");
    exit(1)
}

$errCnt = 0;
foreach my $var ( sort(keys(%$ConfVars) ) ) {
    next if ( $ConfVars->{$var} >= 2 || $var =~ /^\$/ );
    printf("Unused config parameter $var\n");
    $errCnt++;
}
if ( $errCnt ) {
    print("Exiting because of errors\n");
    exit(1)
}

rmtree($DistDir, 0, 0);
mkpath($DistDir, 0, 0777);

foreach my $dir ( qw(bin doc conf images init.d/src cgi-bin
		     lib/BackupPC/CGI
		     lib/BackupPC/Lang
		     lib/BackupPC/Xfer
		     lib/BackupPC/Zip
		) ) {
    mkpath("$DistDir/$dir", 0, 0777);
}

my %ConfName;
my $ConfPod = config2pod();
rmtree("doc", 0, 0);
mkpath("doc", 0, 0777);
InstallFile("doc-src/BackupPC.pod", "doc/BackupPC.pod");

use Pod::Html;
pod2html("doc/BackupPC.pod",
        "--backlink=Back to Top",
        "--header",
        "--title=BackupPC",
        "--outfile=doc/BackupPC.html");

foreach my $file ( (@PerlSrc,
	    <images/*>,
	    qw(
		conf/config.pl
		conf/hosts
		conf/BackupPC_stnd.css
		init.d/README
		init.d/src/debian-backuppc
		init.d/src/gentoo-backuppc
		init.d/src/gentoo-backuppc.conf
		init.d/src/linux-backuppc
		init.d/src/solaris-backuppc
		init.d/src/suse-backuppc
		doc/BackupPC.pod
		doc/BackupPC.html
		README
		LICENSE
		ChangeLog
		configure.pl
        )) ) {
    InstallFile("$file", "$DistDir/$file");
}
rmtree("doc", 0, 0);
system("cd dist ; tar zcf BackupPC-$Version.tar.gz BackupPC-$Version");
print("Distribution written to dist/BackupPC-$Version.tar.gz\n");
unlink("pod2htmd.x~~");
unlink("pod2htmi.x~~");
unlink("pod2htmd.tmp");
unlink("pod2htmi.tmp");

###########################################################################
# Subroutines
###########################################################################

sub InstallFile
{
    my($file, $dest) = @_;

    unlink($dest) if ( -d $dest );
    if ( $file =~ /\.gif/ ) {
        die("can't copy($file, $dest)\n") unless copy($file, $dest);
    } else {
	open(FILE, $file)   || die("can't open $file for reading\n");
	open(OUT, ">$dest") || die("can't open $dest for writing\n");
	binmode(FILE);
	binmode(OUT);
	while ( <FILE> ) {
	    s/^([#*\s]+)Version \d+\.\d+[\.\w]*, released \d+ \w+ \d{4}\.?/$1Version __VERSION__, released __RELEASEDATE__./;
	    s/__VERSION__/$Version/g;
	    s/__RELEASEDATE__/$ReleaseDate/g;
	    if ( $file =~ /BackupPC\.html$/ ) {
		#
		# fixup for conf links
		#
		if ( !/A NAME="item_(%|_)conf/i ) {
		    s/\$Conf{([^}]*)}/
			defined($ConfName{$1})
			    ? "\L<a href=\"#$ConfName{$1}\">\E\$Conf{$1}<\/A>"
			    : "\$Conf{$1}"/eg;
		}
		s/^<DD>/<DD><P>/;
		s/^<li><\/li>/<li>/;
	    }
	    if ( /__CONFIGPOD__/ ) {
		print OUT $ConfPod;
	    } elsif ( /^use lib ".*BackupPC[\d.]*\/lib";/
		    || /^use lib "\/home\/pcbackup\/install\/lib";/ ) {
		print OUT "use lib \"__INSTALLDIR__/lib\";\n";
	    } elsif ( $file =~ /Lib.pm/ && /(.*TopDir *=> .*)'.*',/ ) {
		print OUT "$1'__TOPDIR__',\n";
	    } elsif ( $file =~ /Lib.pm/ && /(.*Version *=> .*)'[\w\d\.]+',/ ) {
		print OUT "$1'$Version',\n";
	    } elsif ( $file =~ /Lib.pm/ && /(.*BinDir *=> .*)'.*',/ ) {
		print OUT "$1'__INSTALLDIR__',\n";
	    } elsif ( $file =~ /Lib.pm/ && /(.*LibDir *=> .*)'.*',/ ) {
		print OUT "$1'__INSTALLDIR__',\n";
	    } elsif ( $file =~ /BackupPC_Admin/ && /(my *\$installDir *= *)'.*'/ ) {
		print OUT "$1'__INSTALLDIR__/lib';\n";
	    } else {
		print OUT;
	    }
	}
	close(FILE);
	close(OUT);
    }
    if ( -x $file ) {
        chmod(0555, $dest);
    } else {
        chmod(0444, $dest);
    }
}

sub config2pod
{
    open(C, "conf/config.pl") || die("can't open conf/config.pl");
    binmode(C);
    my($str, $out, $getHdr, @conf);
    my $first = 1;
    while ( <C> ) {
        chomp;
        s/ +$//;
        if ( /^#########################/ ) {
            if ( $getHdr ) {
                $str =~ s/\n.*//sg;
                $out .= "=back\n\n" if ( !$first );
                $out .= "=head2 $str\n\n=over 4\n\n";
                $str = "";
                $first = 0;
            }
            $getHdr = !$getHdr;
            next;
        }
        if ( /^#/ ) {
            s/# ?//;
            next if ( $str eq "" && /^$/ );
            $str .= $_ . "\n";
            $str .= "\n" if ( $str =~ /examples?:\n$/i );
        } elsif ( /^\$Conf{([^}]*)/ ) {
            my $var = $1;
            s/  +/ /g;
            s/;\s*#.*/;/;
            if ( !s/\[$/[ ... ];/ && !s/<<'EOF'/.../ ) {
                s/([^;])\s*$/$1 .../;
            }
            push(@conf, $_);
            my $text = "_conf_${var}_";
            $text =~ s{[\W\s]}{_}g;
            $ConfName{$var} = "item_$text";
        } elsif ( /^$/ ) {
            if ( $str ne "" && @conf ) {
                $out .= "=item " . join("\n\n=item ", @conf) . "\n\n";
                $out .= $str;
                $out .= "\n" if ( $str !~ /\n$/ );
            }
            $str = "";
            @conf = ();
        }
    }
    if ( $str ne "" && @conf ) {
        $out .= "=item " . join("\n\n=item ", @conf) . "\n\n";
        $out .= $str;
        $out .= "\n" if ( $str !~ /\n$/ );
    }
    $out .= "=back\n\n" if ( !$first );
    return $out;
}

sub CheckConfigParams
{
    my($file, $vars, $check) = @_;
    my $errors;

    open(F, $file) || die("can't open $file\n");
    binmode(F);
    if ( $check ) {
        while ( <F> ) {
            s/\$(self|bpc)->{Conf}{([^}\$]+)}/if ( !defined($vars->{$2}) ) {
                    print("Unexpected Conf var $2 in $file\n");
                    $errors++;
                } else {
                    $vars->{$2}++;
                }/eg;
            s/\$[Cc]onf(?:->)?{([^}\$]+)}/if ( !defined($vars->{$1}) ) {
                    print("Unexpected Conf var $1 in $file\n");
                    $errors++;
                } else {
                    $vars->{$1}++;
                }/eg;
            s/UserCommandRun\("([^"]*)"\)/if ( !defined($vars->{$1}) ) {
                    print("Unexpected Conf var $1 in $file\n");
                    $errors++;
                } else {
                    $vars->{$1}++;
                }/eg;
        }
    } else {
        while ( <F> ) {
            s/^[^#]*\$self->{Conf}{([^}]*)/$vars->{$1} = 1;/eg;
            s/^[^#]*\$Conf{([^}]*)/$vars->{$1} = 1;/eg;
        }
    }
    close(F);
    return $errors;
}

#
# Make sure that every lang variable in cgi-bin/BackupPC_Admin matches
# the strings in each lib/BackupPC/Lang/*.pm file.  This makes sure
# we didn't miss any translations in any of the languages.
#
sub CheckLangUsage
{
    my $errors;
    my $vars = {};

    foreach my $file ( (
		qw(cgi-bin/BackupPC_Admin bin/BackupPC_sendEmail),
		<lib/BackupPC/CGI/*pm>
	    ) ) {
	open(F, $file) || die("can't open $file");
	binmode(F);
	while ( <F> ) {
	    s/\$Lang->{([^}]*)}/$vars->{$1} = 1;/eg;
	}
	close(F);
    }

    foreach my $f ( <lib/BackupPC/Lang/*.pm> ) {
        my $done = {};
        open(F, $f) || die("can't open $f\n");
	binmode(F);
        while ( <F> ) {
            s/#.*//g;
            s/\$Lang{([^}]*)}/
		    my $var = $1;
		    next if ( $var =~ m{^(Reason_|Status_|backupType_)} );
		    next if ( $var eq "Documentation" );
                    if ( !defined($vars->{$var}) ) {
                        print("Unexpected Lang var $var in $f\n");
                        $errors++;
                    } else {
                        $done->{$var} = 1;
                    }/eg;
        }
        close(F);
        foreach my $v ( keys(%$vars) ) {
	    #
	    # skip "variables" with "$", since they are like expressions
	    #
	    next if ( $v =~ /\$/ );
            if ( !defined($done->{$v}) ) {
                print("Lang var $v missing from $f\n");
                $errors++;
            }
        }
    }
    return $errors;
}

#
# Pedantically check that all the html tags in each language file
# match.
#
sub CheckLangTags
{
    my($en, $enVars) = LangParse("lib/BackupPC/Lang/en.pm");
    my($errors);

    foreach my $lang ( qw(fr.pm de.pm es.pm it.pm nl.pm pt_br.pm) ) {
	my($d, $dVars) = LangParse("lib/BackupPC/Lang/$lang");
	foreach my $v1 ( @$en ) {
	    my $v2 = shift(@$d);
	    if ( $v1->{var} ne $v2->{var} ) {
		print("Botch: got $lang var $v2->{var} vs en.pm $v1->{var}\n");
		exit;
	    }
	    my $t1 = LangTextStrip($v1->{val});
	    my $t2 = LangTextStrip($v2->{val});
	    if ( $t1 ne $t2 ) {
		print("$v1->{var}: got en.pm $t1\nvs $lang $t2\n\n");
		$errors++;
	    }
	}
    }
    return $errors;
}

sub LangTextStrip
{
    my($t) = @_;

    $t = "" if ( $t !~ /<.*>/ );
    $t =~ s/^[^<]*</</s;
    $t =~ s/([}>])[^<]*</$1</g;
    $t =~ s/>[^<]*$/>/;
    $t =~ s/(value=)"[^"]*"/$1""/sg;
    $t =~ s/({h[12]\()"[^"]*"/$1""/g;
    $t =~ s/ENG[\s\n]*//sg;
    $t =~ s/^(<<EOF;\n)[^<]*/$1/g;
    return $t;
}

sub LangParse
{
    my($file) = @_;
    open(C, $file) || die("can't open $file");
    binmode(C);
    my($out, @lang, $var);
    my $comment = 1;
    my $allVars = {};
    my $endLine = undef;
    while ( <C> ) {
        if ( /^#/ && !defined($endLine) ) {
            if ( $comment ) {
                $out .= $_;
            } else {
                if ( $out ne "" ) {
                    $allVars->{$var} = @lang if ( defined($var) );
                    push(@lang, {
                        text => $out,
                        var => $var,
                    });
                }
                $var = undef;
                $comment = 1;
                $out = $_;
            }
        } elsif ( /^\s*\$Lang\{([^}]*)/ ) {
            $comment = 0;
            if ( defined($var) ) {
                $allVars->{$var} = @lang if ( defined($var) );
                push(@lang, {
                    text => $out,
                    var => $var,
                });
                $out = $_;
            } else {
                $out .= $_;
            }
            $var = $1;
	    $endLine = $1 if ( /^\s*\$Lang\{[^}]*} *= *<<(.*);/ );
	    $endLine = $1 if ( /^\s*\$Lang\{[^}]*} *= *<<'(.*)';/ );
        } else {
	    $endLine = undef if ( defined($endLine) && /^\Q$endLine[\n\r]*$/ );
            $out .= $_;
        }
    }
    if ( $out ne "" ) {
        $allVars->{$var} = @lang if ( defined($var) );
        push(@lang, {
            text => $out,
            var  => $var,
        });
    }
    close(C);
    foreach my $v ( @lang ) {
	if ( $v->{text} =~ /\$Lang{$v->{var}}\s*=\s*(.*)/s ) {
	    $v->{val} = $1;
	}
    }
    return (\@lang, $allVars);
}
