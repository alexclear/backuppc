#!/bin/perl
#============================================================= -*-perl-*-
#
# BackupPC_sendEmail: send status emails to users and admins
#
# DESCRIPTION
#
#   BackupPC_sendEmail: send status emails to users and admins.
#   BackupPC_sendEmail is run by BackupPC_nightly, so it runs
#   once every night.
#
# AUTHOR
#   Craig Barratt  <cbarratt@users.sourceforge.net>
#
# COPYRIGHT
#   Copyright (C) 2001-2003  Craig Barratt
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#========================================================================
#
# Version 2.1.3, released 21 Jan 2007.
#
# See http://backuppc.sourceforge.net.
#
#========================================================================

use strict;
no  utf8;
use lib "/usr/local/BackupPC2.1.0/lib";
use BackupPC::Lib;
use BackupPC::FileZIO;

use Data::Dumper;
use Getopt::Std;
use DirHandle ();
use vars qw($Lang $TopDir $BinDir %Conf);

die("BackupPC::Lib->new failed\n") if ( !(my $bpc = BackupPC::Lib->new) );
$TopDir = $bpc->TopDir();
$BinDir = $bpc->BinDir();
%Conf   = $bpc->Conf();
$Lang   = $bpc->Lang();

$bpc->ChildInit();

use vars qw(%UserEmailInfo);
do "$TopDir/log/UserEmailInfo.pl";

my %opts;
if ( !getopts("t", \%opts) || @ARGV != 0 ) {
    print("usage: $0 [-t]\n");
    exit(1);
}

my $err = $bpc->ServerConnect($Conf{ServerHost}, $Conf{ServerPort});
if ( $err ) {
    print("Can't connect to server ($err)\n");
    exit(1);
}
my $reply = $bpc->ServerMesg("status hosts");
$reply = $1 if ( $reply =~ /(.*)/s );
my(%Status, %Info, %Jobs, @BgQueue, @UserQueue, @CmdQueue);
eval($reply);

###########################################################################
# Generate sysadmin warning messages
###########################################################################
my $mesg = "";

my @badHosts = ();
foreach my $host ( sort(keys(%Status)) ) {
    next if ( ($Status{$host}{reason} ne "Reason_backup_failed"
               && $Status{$host}{reason} ne "Reason_restore_failed")
           || $Status{$host}{error} =~ /^lost network connection to host/ );
    push(@badHosts, "$host ($Status{$host}{error})");
}
if ( @badHosts ) {
    my $badHosts = join("\n  - ", sort(@badHosts));
    $mesg .= <<EOF;
The following hosts had an error that is probably caused by a
misconfiguration.  Please fix these hosts:
  - $badHosts

EOF
}

#
# Report if we skipped backups because the disk was too full
#
if ( $Info{DUDailySkipHostCntPrev} > 0 ) {
    my $n = $Info{DUDailySkipHostCntPrev};
    my $m = $Conf{DfMaxUsagePct};
    $mesg .= <<EOF;
Yesterday $n hosts were skipped because the file system containing
$TopDir was too full.  The threshold in the
configuration file is $m%, while yesterday the file system was
up to $Info{DUDailyMaxPrev}% full.  Please find more space on the file system,
or reduce the number of full or incremental backups that we keep.

EOF
}

#
# Check for bogus directories (probably PCs that are no longer
# on the backup list)
#
my $d = DirHandle->new("$TopDir/pc") or die("Can't read $TopDir/pc: $!");
my @oldDirs = ();
my @files = $d->read;
$d->close;
foreach my $host ( @files ) {
    next if ( $host =~ /^\./ || defined($Status{$host}) );
    push(@oldDirs, "$TopDir/pc/$host");
}
if ( @oldDirs ) {
    my $oldDirs = join("\n  - ", sort(@oldDirs));
    $mesg .= <<EOF;
The following directories are bogus and are not being used by
BackupPC.  This typically happens when PCs are removed from the
backup list.  If you don't need any old backups from these PCs you
should remove these directories.  If there are machines on this
list that should be backed up then there is a problem with the
hosts file:
  - $oldDirs

EOF
}

if ( $mesg ne "" && $Conf{EMailAdminUserName} ne "" ) {
    $mesg = <<EOF;
To: $Conf{EMailAdminUserName}
Subject: BackupPC administrative attention needed

${mesg}Regards,
PC Backup Genie
EOF
    if ( $opts{t} ) {
        print("#" x 75, "\n");
        print $mesg;
    } else {
	SendMail($mesg);
    }
}

###########################################################################
# Generate per-host warning messages sent to each user
###########################################################################
my $Hosts = $bpc->HostInfoRead();

foreach my $host ( sort(keys(%Status)) ) {
    next if ( $Hosts->{$host}{user} eq "" );
    #
    # read any per-PC config settings (allowing per-PC email settings)
    #
    $bpc->ConfigRead($host);
    %Conf = $bpc->Conf();
    my $user = $Hosts->{$host}{user};
    next if ( time - $UserEmailInfo{$user}{lastTime}
                        < $Conf{EMailNotifyMinDays} * 24*3600 );
    next if ($Conf{XferMethod} eq "archive" );
    my @Backups = $bpc->BackupInfoRead($host);
    my $numBackups = @Backups;
    if ( $numBackups == 0 ) {
        my $subj = defined($Conf{EMailNoBackupEverSubj})
			? $Conf{EMailNoBackupEverSubj}
			: $Lang->{EMailNoBackupEverSubj};
        my $mesg = defined($Conf{EMailNoBackupEverMesg})
		        ? $Conf{EMailNoBackupEverMesg}
			: $Lang->{EMailNoBackupEverMesg};
        sendUserEmail($user, $host, $mesg, $subj, {
                            userName => user2name($user)
                        }) if ( !defined($Jobs{$host}) );
        next;
    }
    my $last = my $lastFull = my $lastIncr = 0;
    my $lastGoodOutlook = 0;
    my $lastNum = -1;
    my $numBadOutlook = 0;
    for ( my $i = 0 ; $i < @Backups ; $i++ ) {
        my $fh;
        $lastNum = $Backups[$i]{num} if ( $lastNum < $Backups[$i]{num} );
        if ( $Backups[$i]{type} eq "full" ) {
            $lastFull = $Backups[$i]{startTime}
                    if ( $lastFull < $Backups[$i]{startTime} );
        } else {
            $lastIncr = $Backups[$i]{startTime}
                    if ( $lastIncr < $Backups[$i]{startTime} );
        }
        $last = $Backups[$i]{startTime}
                    if ( $last < $Backups[$i]{startTime} );
        my $badOutlook = 0;
        my $file = "$TopDir/pc/$host/SmbLOG.$Backups[$i]{num}";
        my $comp = 0;
        if ( !-f $file ) {
            $file = "$TopDir/pc/$host/XferLOG.$Backups[$i]{num}";
            if ( !-f $file ) {
                $comp = 1;
                $file = "$TopDir/pc/$host/SmbLOG.$Backups[$i]{num}.z";
                $file = "$TopDir/pc/$host/XferLOG.$Backups[$i]{num}.z"
                                                        if ( !-f $file );
            }
        }
        next if ( !defined($fh = BackupPC::FileZIO->open($file, 0, $comp)) );
        while ( 1 ) {
            my $s = $fh->readLine();
            last if ( $s eq "" );
            if ( $s =~ /^\s*Error reading file.*\.pst : (ERRDOS - ERRlock|NT_STATUS_FILE_LOCK_CONFLICT)/
                  || $s =~ /^\s*Error reading file.*\.pst\. Got 0 bytes/ ) {
                $badOutlook = 1;
                last;
            }
        }
        $fh->close();
        $numBadOutlook += $badOutlook;
        if ( !$badOutlook ) {
            $lastGoodOutlook = $Backups[$i]{startTime}
                    if ( $lastGoodOutlook < $Backups[$i]{startTime} );
        }
    }
    if ( time - $last > $Conf{EMailNotifyOldBackupDays} * 24*3600 ) {
        my $subj = defined($Conf{EMailNoBackupRecentSubj})
			? $Conf{EMailNoBackupRecentSubj}
			: $Lang->{EMailNoBackupRecentSubj};
        my $mesg = defined($Conf{EMailNoBackupRecentMesg})
			? $Conf{EMailNoBackupRecentMesg}
			: $Lang->{EMailNoBackupRecentMesg};
        my $firstTime = sprintf("%.1f",
                        (time - $Backups[0]{startTime}) / (24*3600));
        my $days = sprintf("%.1f", (time - $last) / (24 * 3600));
        sendUserEmail($user, $host, $mesg, $subj, {
                            firstTime  => $firstTime,
                            days       => $days,
                            userName   => user2name($user),
                            numBackups => $numBackups,
                        }) if ( !defined($Jobs{$host}) );
        next;
    }
    if ( $numBadOutlook > 0
          && time - $lastGoodOutlook > $Conf{EMailNotifyOldOutlookDays}
                                             * 24 * 3600 ) {
        my($days, $howLong);
        if ( $lastGoodOutlook == 0 ) {
            $howLong = eval("qq{$Lang->{howLong_not_been_backed_up}}");
        } else {
            $days = sprintf("%.1f", (time - $lastGoodOutlook) / (24*3600));
            $howLong = eval("qq{$Lang->{howLong_not_been_backed_up_for_days_days}}");
        }
        my $subj = defined($Conf{EMailOutlookBackupSubj})
			? $Conf{EMailOutlookBackupSubj}
			: $Lang->{EMailOutlookBackupSubj};
        my $mesg = defined($Conf{EMailOutlookBackupMesg})
			? $Conf{EMailOutlookBackupMesg}
			: $Lang->{EMailOutlookBackupMesg};
        my $firstTime = sprintf("%.1f",
                        (time - $Backups[0]{startTime}) / (24*3600));
        my $lastTime = sprintf("%.1f",
                        (time - $Backups[$#Backups]{startTime}) / (24*3600));
        sendUserEmail($user, $host, $mesg, $subj, {
                            days       => $days,
                            firstTime  => $firstTime,
                            lastTime   => $lastTime,
                            numBackups => $numBackups,
                            userName   => user2name($user),
                            howLong    => $howLong,
                            serverHost => $Conf{ServerHost},
                        }) if ( !defined($Jobs{$host}) );
    }
}
if ( !$opts{t} ) {
    $Data::Dumper::Indent = 1;
    my $dumpStr = Data::Dumper->Dump(
             [\%UserEmailInfo],
             [qw(*UserEmailInfo)]);
    if ( open(HOST, ">", "$TopDir/log/UserEmailInfo.pl") ) {
	binmode(HOST);
        print(HOST $dumpStr);
        close(HOST);
    }
}

sub user2name
{
    my($user) = @_;
    my($name) = (getpwnam($user))[6];
    $name =~ s/\s.*//;
    $name = $user if ( $name eq "" );
    return $name;
}

sub sendUserEmail
{
    my($user, $host, $mesg, $subj, $vars) = @_;
    $vars->{user}   = $user;
    $vars->{host}   = $host;
    $vars->{domain} = $Conf{EMailUserDestDomain};
    $vars->{CgiURL} = $Conf{CgiURL};
    $subj =~ s/\$(\w+)/defined($vars->{$1}) ? $vars->{$1} : "\$$1"/eg;
    $vars->{subj}   = $subj;
    $mesg =~ s/\$(\w+)/defined($vars->{$1}) ? $vars->{$1} : "\$$1"/eg;
    if ( $opts{t} ) {
        print("#" x 75, "\n");
        print $mesg;
    } else {
    	SendMail($mesg);
    }
    $UserEmailInfo{$user}{lastTime} = time;
    $UserEmailInfo{$user}{lastSubj} = $subj;
    $UserEmailInfo{$user}{lastHost} = $host;
}

sub SendMail
{
    my($mesg) = @_;
    my($from) = $Conf{EMailFromUserName};
    local(*MAIL);

    $from = "-f $from" if ( $from ne "" );
    if ( !open(MAIL, "|$Conf{SendmailPath} -t $from") ) {
    	printf("Can't run sendmail ($Conf{SendmailPath}): $!\n");
	return;
    }
    print MAIL $mesg;
    close(MAIL);
}
